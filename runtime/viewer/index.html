<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>vibe-vibe</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    html, body, #root { width: 100%; height: 100%; }
    body { font-family: system-ui, -apple-system, sans-serif; background: #0a0a0a; color: #fff; }
    #loading {
      display: flex; flex-direction: column; align-items: center; justify-content: center;
      height: 100vh; gap: 16px; color: #94a3b8;
    }
    #loading .spinner {
      width: 32px; height: 32px; border: 2px solid #334155;
      border-top-color: #6366f1; border-radius: 50%;
      animation: spin 0.8s linear infinite;
    }
    @keyframes spin { to { transform: rotate(360deg); } }
    #error-display {
      display: none; padding: 32px; max-width: 600px; margin: 80px auto;
      background: #1e1e2e; border: 1px solid #ef4444; border-radius: 12px;
    }
    #error-display h2 { color: #ef4444; margin-bottom: 12px; }
    #error-display pre { font-size: 13px; color: #94a3b8; white-space: pre-wrap; word-break: break-word; }
    #toast-container {
      position: fixed; top: 16px; right: 16px; z-index: 9999;
      display: flex; flex-direction: column; gap: 8px; max-width: 420px;
      pointer-events: none;
    }
    .toast {
      padding: 12px 16px; border-radius: 8px; font-size: 13px;
      background: #1e1e2e; border: 1px solid #ef4444; color: #f87171;
      white-space: pre-wrap; word-break: break-word;
      animation: toastIn 0.2s ease-out;
      cursor: pointer; pointer-events: auto;
    }
    .toast-build { border-color: #f59e0b; color: #fbbf24; }
    @keyframes toastIn { from { transform: translateX(100%); opacity: 0; } to { transform: translateX(0); opacity: 1; } }
    /* ── Activity panel ─────────────────────────────────── */
    #activity-toggle {
      position: fixed; bottom: 16px; right: 16px; z-index: 9998;
      width: 40px; height: 40px; border-radius: 50%;
      background: #1e1e2e; border: 1px solid #334155;
      color: #94a3b8; font-size: 18px; cursor: pointer;
      display: flex; align-items: center; justify-content: center;
      transition: background 0.15s;
    }
    #activity-toggle:hover { background: #334155; }
    #activity-toggle .badge {
      position: absolute; top: -4px; right: -4px;
      width: 18px; height: 18px; border-radius: 50%;
      background: #6366f1; color: #fff; font-size: 10px; font-weight: 700;
      display: flex; align-items: center; justify-content: center;
    }
    #activity-panel {
      position: fixed; bottom: 64px; right: 16px; z-index: 9998;
      width: 320px; max-height: 420px; border-radius: 12px;
      background: #111113; border: 1px solid #1e1e24;
      box-shadow: 0 8px 32px rgba(0,0,0,0.5);
      display: none; flex-direction: column; overflow: hidden;
    }
    #activity-panel.open { display: flex; }
    #activity-panel .panel-header {
      padding: 12px 16px; border-bottom: 1px solid #1e1e24;
      font-size: 12px; font-weight: 700; color: #6b6b80;
      text-transform: uppercase; letter-spacing: 0.06em;
      display: flex; justify-content: space-between; align-items: center;
    }
    #participant-list {
      padding: 8px 16px; border-bottom: 1px solid #1e1e24;
      display: flex; flex-wrap: wrap; gap: 6px;
    }
    .participant-chip {
      padding: 3px 10px; border-radius: 9999px; font-size: 11px; font-weight: 500;
    }
    .participant-chip.human { background: #1e293b; color: #60a5fa; }
    .participant-chip.ai { background: #1a1625; color: #a78bfa; }
    .participant-chip.unknown { background: #1e1e24; color: #6b6b80; }
    #event-log {
      flex: 1; overflow-y: auto; padding: 8px 0;
    }
    .event-entry {
      padding: 6px 16px; font-size: 12px; line-height: 1.5;
      border-bottom: 1px solid #0a0a0a;
    }
    .event-entry:hover { background: #1e1e24; }
    .event-actor { font-weight: 600; }
    .event-actor.human { color: #60a5fa; }
    .event-actor.ai { color: #a78bfa; }
    .event-tool { color: #6366f1; font-weight: 500; }
    .event-time { color: #4a4a5a; font-size: 10px; float: right; }
    .event-error { color: #f87171; }
  </style>
</head>
<body>
  <div id="loading">
    <div class="spinner"></div>
    <div>Loading experience...</div>
  </div>
  <div id="error-display">
    <h2>Experience Error</h2>
    <pre id="error-message"></pre>
  </div>
  <div id="toast-container"></div>
  <button id="activity-toggle" onclick="toggleActivityPanel()" title="Activity log">
    &#9776;
  </button>
  <div id="activity-panel">
    <div class="panel-header">
      <span>Participants</span>
      <span id="participant-count">0</span>
    </div>
    <div id="participant-list"></div>
    <div class="panel-header">
      <span>Activity</span>
      <span id="event-count">0</span>
    </div>
    <div id="event-log"></div>
  </div>
  <div id="root"></div>

  <!-- External deps from CDN -->
  <script type="importmap">
  {
    "imports": {
      "react": "https://esm.sh/react@18.2.0",
      "react/jsx-runtime": "https://esm.sh/react@18.2.0/jsx-runtime",
      "react-dom": "https://esm.sh/react-dom@18.2.0",
      "react-dom/client": "https://esm.sh/react-dom@18.2.0/client",
      "zod": "https://esm.sh/zod@3.22.4",
      "yjs": "https://esm.sh/yjs@13.6.10"
    }
  }
  </script>
  <!-- Screenshot capture (html2canvas for DOM/SVG, canvas.toDataURL for <canvas>) -->
  <script src="https://cdn.jsdelivr.net/npm/html2canvas@1.4.1/dist/html2canvas.min.js"></script>
  <script type="module">
    import React from "react";
    import ReactDOM from "react-dom/client";
    import { z } from "zod";
    import * as Y from "yjs";

    // ── Set up globalThis ────────────────────────────────────

    globalThis.React = React;
    globalThis.Y = Y;
    globalThis.z = z;

    // SDK define helpers (same contract as @vibevibes/sdk)
    globalThis.defineExperience = (config) => config;
    globalThis.defineTool = (config) => ({ risk: "low", capabilities_required: [], ...config });
    globalThis.defineTest = (config) => config;
    globalThis.quickTool = (name, desc, schema, handler) =>
      globalThis.defineTool({ name, description: desc, input_schema: schema, handler });

    // Hooks — implemented inline for the local viewer
    const { useState, useEffect, useCallback, useRef } = React;

    function useSharedState(key, defaultValue) {
      const ctx = globalThis.__vibevibes_ctx__;
      if (!ctx) return [defaultValue, () => {}];
      const value = ctx.sharedState?.[key] ?? defaultValue;
      return [value, () => {}]; // read-only from hooks; mutations go through callTool
    }

    function useToolCall() {
      const ctx = globalThis.__vibevibes_ctx__;
      return ctx?.callTool || (async () => {});
    }

    function useOptimisticTool(toolName) {
      const ctx = globalThis.__vibevibes_ctx__;
      const callTool = ctx?.callTool || (async () => {});
      return useCallback(
        (input, predictFn) => callTool(toolName, input),
        [toolName, callTool]
      );
    }

    function useParticipants() {
      const ctx = globalThis.__vibevibes_ctx__;
      return ctx?.participants || [];
    }

    function useAnimationFrame(callback) {
      const callbackRef = useRef(callback);
      callbackRef.current = callback;
      useEffect(() => {
        let running = true;
        function loop(time) {
          if (!running) return;
          callbackRef.current(time);
          requestAnimationFrame(loop);
        }
        requestAnimationFrame(loop);
        return () => { running = false; };
      }, []);
    }

    function useFollow() { return [null, () => {}]; }
    function useTypingIndicator() { return [[], () => {}]; }

    // useUndo — tracks state snapshots, restores via _state.restore tool
    function useUndo(sharedState, callTool, opts) {
      const maxHistory = opts?.maxHistory ?? 50;
      const restoreTool = opts?.restoreTool ?? '_state.restore';
      const undoStackRef = useRef([]);
      const redoStackRef = useRef([]);
      const lastStateRef = useRef(null);
      const restoringRef = useRef(false);
      const [, forceRender] = useState(0);

      useEffect(() => {
        if (restoringRef.current) { restoringRef.current = false; lastStateRef.current = sharedState; return; }
        if (lastStateRef.current !== null && lastStateRef.current !== sharedState) {
          undoStackRef.current = [...undoStackRef.current.slice(-(maxHistory - 1)), lastStateRef.current];
          redoStackRef.current = [];
          forceRender(n => n + 1);
        }
        lastStateRef.current = sharedState;
      }, [sharedState]);

      const undo = useCallback(() => {
        const stack = undoStackRef.current;
        if (stack.length === 0) return;
        const prev = stack[stack.length - 1];
        undoStackRef.current = stack.slice(0, -1);
        redoStackRef.current = [...redoStackRef.current, sharedState];
        restoringRef.current = true;
        forceRender(n => n + 1);
        callTool(restoreTool, { state: prev }).catch(() => {});
      }, [sharedState, callTool]);

      const redo = useCallback(() => {
        const stack = redoStackRef.current;
        if (stack.length === 0) return;
        const next = stack[stack.length - 1];
        redoStackRef.current = stack.slice(0, -1);
        undoStackRef.current = [...undoStackRef.current, sharedState];
        restoringRef.current = true;
        forceRender(n => n + 1);
        callTool(restoreTool, { state: next }).catch(() => {});
      }, [sharedState, callTool]);

      return { undo, redo, canUndo: undoStackRef.current.length > 0, canRedo: redoStackRef.current.length > 0, undoCount: undoStackRef.current.length, redoCount: redoStackRef.current.length };
    }

    // useDebounce — collapse rapid calls into one after delay
    function useDebounce(callTool, delayMs = 300) {
      const timerRef = useRef(null);
      const latestRef = useRef(null);
      useEffect(() => () => { if (timerRef.current) clearTimeout(timerRef.current); }, []);
      return useCallback((name, input) => {
        latestRef.current = { name, input };
        if (timerRef.current) clearTimeout(timerRef.current);
        return new Promise((resolve, reject) => {
          timerRef.current = setTimeout(async () => {
            const latest = latestRef.current;
            if (!latest) return;
            try { resolve(await callTool(latest.name, latest.input)); } catch (err) { reject(err); }
          }, delayMs);
        });
      }, [callTool, delayMs]);
    }

    // useThrottle — at most one call per interval
    function useThrottle(callTool, intervalMs = 50) {
      const lastCallRef = useRef(0);
      const timerRef = useRef(null);
      const latestRef = useRef(null);
      useEffect(() => () => { if (timerRef.current) clearTimeout(timerRef.current); }, []);
      return useCallback((name, input) => {
        latestRef.current = { name, input };
        const now = Date.now();
        const elapsed = now - lastCallRef.current;
        if (elapsed >= intervalMs) { lastCallRef.current = now; return callTool(name, input); }
        if (timerRef.current) clearTimeout(timerRef.current);
        return new Promise((resolve, reject) => {
          timerRef.current = setTimeout(async () => {
            lastCallRef.current = Date.now();
            const latest = latestRef.current;
            if (!latest) return;
            try { resolve(await callTool(latest.name, latest.input)); } catch (err) { reject(err); }
          }, intervalMs - elapsed);
        });
      }, [callTool, intervalMs]);
    }

    globalThis.undoTool = (zod) => ({
      name: "_state.restore",
      description: "Restore shared state to a previous snapshot (used by undo/redo)",
      input_schema: zod.object({ state: zod.record(zod.any()) }),
      risk: "low", capabilities_required: ["state.write"],
      handler: async (ctx, input) => { ctx.setState(input.state); return { restored: true }; },
    });

    globalThis.vibevibesHooks = {
      useToolCall, useSharedState, useOptimisticTool, useParticipants,
      useAnimationFrame, useFollow, useTypingIndicator,
      useUndo, useDebounce, useThrottle,
    };

    // UI Components (minimal inline versions)
    const ce = React.createElement;
    globalThis.vibevibesComponents = {
      Button: ({ onClick, children, variant, ...props }) =>
        ce("button", {
          onClick,
          style: {
            padding: "8px 16px", borderRadius: "6px", cursor: "pointer",
            background: variant === "ghost" ? "transparent" : "#6366f1",
            color: "#fff", border: variant === "ghost" ? "1px solid #334155" : "none",
            fontSize: "14px", ...props.style,
          },
          ...props,
        }, children),
      Card: ({ children, ...props }) =>
        ce("div", {
          style: { background: "#1e1e2e", borderRadius: "12px", padding: "16px", border: "1px solid #334155", ...props.style },
          ...props,
        }, children),
      Input: (props) =>
        ce("input", {
          style: {
            padding: "8px 12px", borderRadius: "6px", background: "#1e293b",
            color: "#fff", border: "1px solid #334155", outline: "none", width: "100%",
            ...props.style,
          },
          ...props,
        }),
      Badge: ({ children, ...props }) =>
        ce("span", {
          style: { padding: "2px 8px", borderRadius: "9999px", background: "#334155", color: "#94a3b8", fontSize: "12px", ...props.style },
          ...props,
        }, children),
      Stack: ({ children, gap, direction, ...props }) =>
        ce("div", {
          style: { display: "flex", flexDirection: direction || "column", gap: gap || "8px", ...props.style },
          ...props,
        }, children),
      Grid: ({ children, columns, gap, ...props }) =>
        ce("div", {
          style: { display: "grid", gridTemplateColumns: `repeat(${columns || 2}, 1fr)`, gap: gap || "8px", ...props.style },
          ...props,
        }, children),
      Slider: ({ value = 50, onChange, min = 0, max = 100, step = 1, disabled, label, ...props }) => {
        const pct = ((value - min) / (max - min)) * 100;
        return ce("div", { style: { display: "flex", flexDirection: "column", gap: "4px", ...props.style } },
          label ? ce("div", { style: { display: "flex", justifyContent: "space-between", fontSize: "13px", color: "#94a3b8" } },
            ce("span", null, label), ce("span", null, String(value))) : null,
          ce("input", { type: "range", min, max, step, value, disabled,
            onChange: onChange ? (e) => onChange(parseFloat(e.target.value)) : undefined,
            style: { width: "100%", height: "6px", appearance: "none", background: `linear-gradient(to right, #6366f1 ${pct}%, #334155 ${pct}%)`, borderRadius: "3px", outline: "none", cursor: disabled ? "not-allowed" : "pointer" },
          })
        );
      },
      Textarea: ({ value, onChange, placeholder, rows = 3, disabled, ...props }) =>
        ce("textarea", { value, placeholder, rows, disabled,
          onChange: onChange ? (e) => onChange(e.target.value) : undefined,
          style: { width: "100%", padding: "8px 12px", fontSize: "14px", border: "1px solid #334155", borderRadius: "6px", background: "#1e293b", color: "#fff", outline: "none", resize: "vertical", boxSizing: "border-box", fontFamily: "system-ui, sans-serif", ...props.style },
        }),
      Modal: ({ children, open, onClose, title, ...props }) => {
        if (!open) return null;
        return ce("div", { onClick: onClose, style: { position: "fixed", inset: 0, zIndex: 10000, display: "flex", alignItems: "center", justifyContent: "center", background: "rgba(0,0,0,0.6)", backdropFilter: "blur(4px)" } },
          ce("div", { onClick: (e) => e.stopPropagation(), style: { background: "#1e1e2e", borderRadius: "12px", padding: "24px", boxShadow: "0 20px 60px rgba(0,0,0,0.5)", maxWidth: "480px", width: "90%", maxHeight: "80vh", overflowY: "auto", border: "1px solid #334155", ...props.style } },
            title ? ce("div", { style: { display: "flex", justifyContent: "space-between", alignItems: "center", marginBottom: "16px" } },
              ce("h3", { style: { margin: 0, fontSize: "1.1rem", fontWeight: 600, color: "#fff" } }, title),
              onClose ? ce("button", { onClick: onClose, style: { background: "none", border: "none", fontSize: "1.25rem", cursor: "pointer", color: "#94a3b8", padding: "4px" } }, "\u2715") : null
            ) : null,
            children
          )
        );
      },
      ColorPicker: ({ value = "#6366f1", onChange, presets, disabled, ...props }) => {
        const colors = presets || ["#ef4444","#f97316","#eab308","#22c55e","#06b6d4","#3b82f6","#6366f1","#8b5cf6","#ec4899","#ffffff","#94a3b8","#0a0a0a"];
        return ce("div", { style: { display: "flex", flexWrap: "wrap", gap: "6px", alignItems: "center", ...props.style } },
          ...colors.map(c => ce("button", { key: c, onClick: !disabled && onChange ? () => onChange(c) : undefined,
            style: { width: "28px", height: "28px", borderRadius: "50%", border: c === value ? "2px solid #fff" : "2px solid transparent", background: c, cursor: disabled ? "not-allowed" : "pointer", outline: c === value ? "2px solid #6366f1" : "none", outlineOffset: "2px", padding: 0 } })),
          ce("input", { type: "color", value, disabled, onChange: onChange ? (e) => onChange(e.target.value) : undefined,
            style: { width: "28px", height: "28px", padding: 0, border: "none", borderRadius: "50%", cursor: "pointer" } })
        );
      },
      Dropdown: ({ value, onChange, options = [], placeholder, disabled, ...props }) =>
        ce("select", { value: value || "", disabled, onChange: onChange ? (e) => onChange(e.target.value) : undefined,
          style: { width: "100%", padding: "8px 12px", fontSize: "14px", border: "1px solid #334155", borderRadius: "6px", background: "#1e293b", color: "#fff", outline: "none", cursor: "pointer", appearance: "none", paddingRight: "2rem", ...props.style } },
          placeholder ? ce("option", { value: "", disabled: true }, placeholder) : null,
          ...options.map(o => ce("option", { key: o.value, value: o.value }, o.label))
        ),
      Tabs: ({ tabs = [], activeTab, onTabChange, children, ...props }) => {
        const active = activeTab || tabs[0]?.id;
        return ce("div", { style: { ...props.style } },
          ce("div", { style: { display: "flex", borderBottom: "1px solid #334155", gap: 0 } },
            ...tabs.map(t => ce("button", { key: t.id, onClick: onTabChange ? () => onTabChange(t.id) : undefined,
              style: { padding: "8px 16px", fontSize: "13px", fontWeight: 500, background: "none", border: "none", cursor: "pointer", color: t.id === active ? "#6366f1" : "#94a3b8", borderBottom: t.id === active ? "2px solid #6366f1" : "2px solid transparent", marginBottom: "-1px" } }, t.label))
          ),
          ce("div", { style: { paddingTop: "12px" } }, children)
        );
      },
    };

    // ── Activity panel ─────────────────────────────────────

    let activityPanelOpen = false;
    let unseenEvents = 0;
    const activityEvents = [];
    const MAX_ACTIVITY_EVENTS = 100;

    globalThis.toggleActivityPanel = function() {
      activityPanelOpen = !activityPanelOpen;
      document.getElementById("activity-panel").classList.toggle("open", activityPanelOpen);
      if (activityPanelOpen) {
        unseenEvents = 0;
        updateToggleBadge();
      }
    };

    function updateToggleBadge() {
      const toggle = document.getElementById("activity-toggle");
      let badge = toggle.querySelector(".badge");
      if (unseenEvents > 0) {
        if (!badge) { badge = document.createElement("span"); badge.className = "badge"; toggle.appendChild(badge); }
        badge.textContent = unseenEvents > 9 ? "9+" : String(unseenEvents);
      } else if (badge) {
        badge.remove();
      }
    }

    function parseActorId(id) {
      const m = id.match(/^(.+)-(human|ai)-(\d+)$/);
      if (m) return { username: m[1], type: m[2] };
      return { username: id, type: "unknown" };
    }

    function updateParticipantList(participants) {
      const el = document.getElementById("participant-list");
      const countEl = document.getElementById("participant-count");
      countEl.textContent = String(participants.length);
      el.innerHTML = "";
      for (const pid of participants) {
        const { username, type } = parseActorId(pid);
        const chip = document.createElement("span");
        chip.className = `participant-chip ${type}`;
        chip.textContent = (type === "ai" ? "\u{1F916} " : "") + username;
        chip.title = pid;
        el.appendChild(chip);
      }
    }

    function addActivityEvent(event) {
      activityEvents.push(event);
      if (activityEvents.length > MAX_ACTIVITY_EVENTS) activityEvents.shift();

      const log = document.getElementById("event-log");
      const countEl = document.getElementById("event-count");
      countEl.textContent = String(activityEvents.length);

      const entry = document.createElement("div");
      entry.className = "event-entry";

      const { type: actorType } = parseActorId(event.actorId || "unknown");
      const time = new Date(event.ts).toLocaleTimeString([], { hour: "2-digit", minute: "2-digit", second: "2-digit" });

      entry.innerHTML = `<span class="event-time">${time}</span>`
        + `<span class="event-actor ${actorType}">${event.actorId}</span> `
        + `<span class="event-tool">${event.tool}</span>`
        + (event.error ? ` <span class="event-error">ERR</span>` : "");

      log.appendChild(entry);
      log.scrollTop = log.scrollHeight;

      if (!activityPanelOpen) {
        unseenEvents++;
        updateToggleBadge();
      }
    }

    // ── Toast notifications ─────────────────────────────────

    function showToast(message, type = "error", durationMs = 6000) {
      const container = document.getElementById("toast-container");
      const toast = document.createElement("div");
      toast.className = type === "build" ? "toast toast-build" : "toast";
      toast.textContent = message;
      toast.onclick = () => toast.remove();
      container.appendChild(toast);
      setTimeout(() => { if (toast.parentNode) toast.remove(); }, durationMs);
    }

    // ── Connect to the experience ─────────────────────────────

    const SERVER = location.origin;
    const WS_PROTO = location.protocol === "https:" ? "wss:" : "ws:";
    const WS_URL = `${WS_PROTO}//${location.host}`;

    // Room-aware: read ?room= query param (defaults to "local" for host experience)
    const ROOM_ID = new URLSearchParams(location.search).get("room") || "local";

    function showError(msg) {
      document.getElementById("loading").style.display = "none";
      document.getElementById("error-display").style.display = "block";
      document.getElementById("error-message").textContent = msg;
    }

    async function start() {
      try {
        // Connect WebSocket — single room, no room ID needed
        const ws = new WebSocket(WS_URL);

        let actorId = "viewer";
        let sharedState = {};
        let participants = [];
        let roomConfig = {};
        let Canvas = null;

        function render() {
          if (!Canvas || !reactRoot) return;

          // Expose context for hooks
          globalThis.__vibevibes_ctx__ = {
            sharedState,
            callTool,
            participants,
            actorId,
          };

          reactRoot.render(
            ce(CanvasErrorBoundary, null,
              ce(Canvas, {
                roomId: ROOM_ID,
                actorId,
                sharedState,
                callTool,
                participants,
                ephemeralState: {},
                setEphemeral: () => {},
                roomConfig,
              })
            )
          );
        }

        async function callTool(name, input) {
          try {
            const toolUrl = ROOM_ID === "local"
              ? `${SERVER}/tools/${name}`
              : `${SERVER}/rooms/${ROOM_ID}/tools/${name}`;
            const res = await fetch(toolUrl, {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({ actorId, input: input || {} }),
            });
            const data = await res.json();
            if (data.error) {
              showToast(data.error);
              throw new Error(data.error);
            }
            return data.output;
          } catch (err) {
            if (!err.message || !document.querySelector(".toast")) {
              showToast(`Tool '${name}' failed: ${err.message}`);
            }
            throw err;
          }
        }

        // Error boundary component
        class CanvasErrorBoundary extends React.Component {
          constructor(props) {
            super(props);
            this.state = { error: null };
          }
          static getDerivedStateFromError(error) { return { error }; }
          componentDidCatch(error, info) {
            console.error("[viewer] Experience crashed:", error, info?.componentStack);
          }
          render() {
            if (this.state.error) {
              return ce("div", {
                style: { padding: "32px", textAlign: "center", color: "#ef4444" },
              },
                ce("h2", null, "Experience Crashed"),
                ce("pre", { style: { fontSize: "13px", color: "#94a3b8", marginTop: "12px", whiteSpace: "pre-wrap" } },
                  this.state.error.message),
                ce("button", {
                  onClick: () => this.setState({ error: null }),
                  style: { marginTop: "16px", padding: "8px 16px", background: "#6366f1", color: "#fff", border: "none", borderRadius: "6px", cursor: "pointer" },
                }, "Try Again"),
              );
            }
            return this.props.children;
          }
        }

        ws.onopen = () => {
          reconnectAttempts = 0; // Reset backoff on successful connection
          ws.send(JSON.stringify({ type: "join", username: "viewer", roomId: ROOM_ID }));
        };

        ws.onmessage = async (event) => {
          const msg = JSON.parse(event.data);

          if (msg.type === "joined") {
            actorId = msg.actorId;
            sharedState = msg.sharedState || {};
            participants = msg.participants || [];
            roomConfig = msg.config || {};

            // Load client bundle (room-aware: external experiences get their own bundle)
            try {
              const bundleUrl = ROOM_ID === "local"
                ? `${SERVER}/bundle?_t=${Date.now()}`
                : `${SERVER}/rooms/${ROOM_ID}/bundle?_t=${Date.now()}`;
              const bundleRes = await fetch(bundleUrl);
              const bundleCode = await bundleRes.text();

              const blob = new Blob([bundleCode], { type: "text/javascript" });
              const url = URL.createObjectURL(blob);
              const mod = await import(url);
              URL.revokeObjectURL(url);

              const experience = mod.default ?? mod;
              if (!experience?.Canvas) throw new Error("Experience has no Canvas component");

              Canvas = experience.Canvas;
              if (!reactRoot) {
                reactRoot = ReactDOM.createRoot(document.getElementById("root"));
              }

              document.getElementById("loading").style.display = "none";
              render();
              updateParticipantList(participants);
            } catch (err) {
              showError(`Failed to load experience: ${err.message}`);
            }
          }

          if (msg.type === "shared_state_update") {
            sharedState = msg.state;
            participants = msg.participants || participants;
            render();
            updateParticipantList(participants);
            if (msg.event) addActivityEvent(msg.event);
          }

          if (msg.type === "presence_update") {
            participants = msg.participants || participants;
            render();
            updateParticipantList(participants);
          }

          if (msg.type === "experience_updated") {
            // Hot reload: re-fetch bundle and re-render
            try {
              const bundleUrl = ROOM_ID === "local"
                ? `${SERVER}/bundle?_t=${Date.now()}`
                : `${SERVER}/rooms/${ROOM_ID}/bundle?_t=${Date.now()}`;
              const bundleRes = await fetch(bundleUrl);
              const bundleCode = await bundleRes.text();

              const blob = new Blob([bundleCode], { type: "text/javascript" });
              const url = URL.createObjectURL(blob);
              const mod = await import(url);
              URL.revokeObjectURL(url);

              const experience = mod.default ?? mod;
              if (experience?.Canvas) {
                Canvas = experience.Canvas;
                render();
                console.log("[viewer] Hot reloaded");
              }
            } catch (err) {
              console.error("[viewer] Hot reload failed:", err);
              showToast(`Hot reload failed: ${err.message}`, "build", 10000);
            }
          }

          if (msg.type === "build_error") {
            showToast(`Build error: ${msg.error}`, "build", 10000);
          }

          if (msg.type === "screenshot_request") {
            const requestId = msg.id;
            // Small delay to let any pending React renders settle
            setTimeout(async () => {
              try {
                const root = document.getElementById("root");
                if (!root) throw new Error("No #root element");

                let dataUrl;

                // Fast path: single <canvas> filling #root → native toDataURL
                const canvases = root.querySelectorAll("canvas");
                if (canvases.length === 1) {
                  const cvs = canvases[0];
                  const rootRect = root.getBoundingClientRect();
                  const cvsRect = cvs.getBoundingClientRect();
                  const fillsRoot =
                    Math.abs(cvsRect.width - rootRect.width) < 20 &&
                    Math.abs(cvsRect.height - rootRect.height) < 20;
                  if (fillsRoot) {
                    dataUrl = cvs.toDataURL("image/png");
                  }
                }

                // Fallback: html2canvas for DOM/SVG/mixed content
                if (!dataUrl && typeof html2canvas === "function") {
                  const captured = await html2canvas(root, {
                    backgroundColor: "#0a0a0a",
                    useCORS: true,
                    logging: false,
                    scale: 1,
                  });
                  dataUrl = captured.toDataURL("image/png");
                }

                if (!dataUrl) throw new Error("No capture method available");

                ws.send(JSON.stringify({
                  type: "screenshot_response",
                  id: requestId,
                  dataUrl,
                }));
              } catch (err) {
                ws.send(JSON.stringify({
                  type: "screenshot_response",
                  id: requestId,
                  error: err.message,
                }));
              }
            }, 100);
          }
        };

        ws.onerror = (err) => {
          console.error("[viewer] WebSocket error:", err);
        };

        // Reconnect with exponential backoff (no full page reload)
        ws.onclose = () => {
          const delay = Math.min(1000 * Math.pow(2, reconnectAttempts), 15000);
          reconnectAttempts++;
          console.log(`[viewer] WebSocket closed, reconnecting in ${delay}ms (attempt ${reconnectAttempts})...`);
          showToast(`Disconnected. Reconnecting in ${Math.round(delay/1000)}s...`, "info", delay + 1000);
          setTimeout(() => start(), delay);
        };

      } catch (err) {
        showError(err.message);
      }
    }

    let reconnectAttempts = 0;
    let reactRoot = null; // Persists across reconnects to avoid duplicate roots
    start();
  </script>
</body>
</html>
