<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>vibe-vibe</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    html, body, #root { width: 100%; height: 100%; }
    body { font-family: system-ui, -apple-system, sans-serif; background: #0a0a0a; color: #fff; }
    #loading {
      display: flex; flex-direction: column; align-items: center; justify-content: center;
      height: 100vh; gap: 16px; color: #94a3b8;
    }
    #loading .spinner {
      width: 32px; height: 32px; border: 2px solid #334155;
      border-top-color: #6366f1; border-radius: 50%;
      animation: spin 0.8s linear infinite;
    }
    @keyframes spin { to { transform: rotate(360deg); } }
    #error-display {
      display: none; padding: 32px; max-width: 600px; margin: 80px auto;
      background: #1e1e2e; border: 1px solid #ef4444; border-radius: 12px;
    }
    #error-display h2 { color: #ef4444; margin-bottom: 12px; }
    #error-display pre { font-size: 13px; color: #94a3b8; white-space: pre-wrap; word-break: break-word; }
    #toast-container {
      position: fixed; top: 16px; right: 16px; z-index: 9999;
      display: flex; flex-direction: column; gap: 8px; max-width: 420px;
      pointer-events: none;
    }
    .toast {
      padding: 12px 16px; border-radius: 8px; font-size: 13px;
      background: #1e1e2e; border: 1px solid #ef4444; color: #f87171;
      white-space: pre-wrap; word-break: break-word;
      animation: toastIn 0.2s ease-out;
      cursor: pointer; pointer-events: auto;
    }
    .toast-build { border-color: #f59e0b; color: #fbbf24; }
    @keyframes toastIn { from { transform: translateX(100%); opacity: 0; } to { transform: translateX(0); opacity: 1; } }
    /* ── Activity panel ─────────────────────────────────── */
    #activity-toggle {
      position: fixed; bottom: 16px; right: 16px; z-index: 9998;
      width: 40px; height: 40px; border-radius: 50%;
      background: #1e1e2e; border: 1px solid #334155;
      color: #94a3b8; font-size: 18px; cursor: pointer;
      display: flex; align-items: center; justify-content: center;
      transition: background 0.15s;
    }
    #activity-toggle:hover { background: #334155; }
    #activity-toggle .badge {
      position: absolute; top: -4px; right: -4px;
      width: 18px; height: 18px; border-radius: 50%;
      background: #6366f1; color: #fff; font-size: 10px; font-weight: 700;
      display: flex; align-items: center; justify-content: center;
    }
    #activity-panel {
      position: fixed; bottom: 64px; right: 16px; z-index: 9998;
      width: 320px; max-height: 420px; border-radius: 12px;
      background: #111113; border: 1px solid #1e1e24;
      box-shadow: 0 8px 32px rgba(0,0,0,0.5);
      display: none; flex-direction: column; overflow: hidden;
    }
    #activity-panel.open { display: flex; }
    #activity-panel .panel-header {
      padding: 12px 16px; border-bottom: 1px solid #1e1e24;
      font-size: 12px; font-weight: 700; color: #6b6b80;
      text-transform: uppercase; letter-spacing: 0.06em;
      display: flex; justify-content: space-between; align-items: center;
    }
    #participant-list {
      padding: 8px 16px; border-bottom: 1px solid #1e1e24;
      display: flex; flex-wrap: wrap; gap: 6px;
    }
    .participant-chip {
      padding: 3px 10px; border-radius: 9999px; font-size: 11px; font-weight: 500;
    }
    .participant-chip.human { background: #1e293b; color: #60a5fa; }
    .participant-chip.ai { background: #1a1625; color: #a78bfa; }
    .participant-chip.unknown { background: #1e1e24; color: #6b6b80; }
    #event-log {
      flex: 1; overflow-y: auto; padding: 8px 0;
    }
    .event-entry {
      padding: 6px 16px; font-size: 12px; line-height: 1.5;
      border-bottom: 1px solid #0a0a0a;
    }
    .event-entry:hover { background: #1e1e24; }
    .event-actor { font-weight: 600; }
    .event-actor.human { color: #60a5fa; }
    .event-actor.ai { color: #a78bfa; }
    .event-tool { color: #6366f1; font-weight: 500; }
    .event-time { color: #4a4a5a; font-size: 10px; float: right; }
    .event-error { color: #f87171; }
  </style>
</head>
<body>
  <div id="loading">
    <div class="spinner"></div>
    <div>Loading experience...</div>
  </div>
  <div id="error-display">
    <h2>Experience Error</h2>
    <pre id="error-message"></pre>
  </div>
  <div id="toast-container"></div>
  <button id="activity-toggle" onclick="toggleActivityPanel()" title="Activity log">
    &#9776;
  </button>
  <div id="activity-panel">
    <div class="panel-header">
      <span>Participants</span>
      <span id="participant-count">0</span>
    </div>
    <div id="participant-list"></div>
    <div class="panel-header">
      <span>Activity</span>
      <span id="event-count">0</span>
    </div>
    <div id="event-log"></div>
  </div>
  <div id="root"></div>

  <!-- External deps from CDN -->
  <script type="importmap">
  {
    "imports": {
      "react": "https://esm.sh/react@18.2.0",
      "react/jsx-runtime": "https://esm.sh/react@18.2.0/jsx-runtime",
      "react-dom": "https://esm.sh/react-dom@18.2.0",
      "react-dom/client": "https://esm.sh/react-dom@18.2.0/client",
      "zod": "https://esm.sh/zod@3.22.4",
      "yjs": "https://esm.sh/yjs@13.6.10",
      "@vibevibes/sdk": "/sdk.js"
    }
  }
  </script>
  <!-- Screenshot capture (html2canvas for DOM/SVG, canvas.toDataURL for <canvas>) -->
  <script src="https://cdn.jsdelivr.net/npm/html2canvas@1.4.1/dist/html2canvas.min.js"></script>
  <script type="module">
    import React from "react";
    import ReactDOM from "react-dom/client";
    import { z } from "zod";
    import * as Y from "yjs";

    // ── Set up globalThis ────────────────────────────────────

    globalThis.React = React;
    globalThis.Y = Y;

    // ── Scene Engine (loaded from SDK dist) ────────────────────
    try {
      const sdk = await import("@vibevibes/sdk");
      globalThis.vibevibesScene = {
        SceneRenderer: sdk.SceneRenderer,
        SvgSceneRenderer: sdk.SvgSceneRenderer,
        useSceneTweens: sdk.useSceneTweens,
        useParticleTick: sdk.useParticleTick,
        useSceneInteraction: sdk.useSceneInteraction,
        useSceneDrag: sdk.useSceneDrag,
        useSceneSelection: sdk.useSceneSelection,
        useSceneViewport: sdk.useSceneViewport,
        createScene: sdk.createScene,
        createNode: sdk.createNode,
        sceneTools: sdk.sceneTools,
        sceneHints: sdk.sceneHints,
        createSceneTools: sdk.createSceneTools,
        createSceneHints: sdk.createSceneHints,
        createSceneSchemas: sdk.createSceneSchemas,
        walkNodes: sdk.walkNodes,
        nodeById: sdk.nodeById,
        findNodes: sdk.findNodes,
        allNodeIds: sdk.allNodeIds,
        nodeCount: sdk.nodeCount,
        cloneScene: sdk.cloneScene,
        removeNodeById: sdk.removeNodeById,
        findParent: sdk.findParent,
        PathBuilder: sdk.PathBuilder,
        easingFunctions: sdk.easingFunctions,
        interpolateTween: sdk.interpolateTween,
        createRuleTools: sdk.createRuleTools,
        createRuleHints: sdk.createRuleHints,
        ruleTools: sdk.ruleTools,
        useRuleTick: sdk.useRuleTick,
        nodeMatchesSelector: sdk.nodeMatchesSelector,
      };
    } catch (e) {
      console.warn("[vibevibes] Scene SDK not available:", e.message);
      globalThis.vibevibesScene = {};
    }
    globalThis.z = z;

    // SDK define helpers (same contract as @vibevibes/sdk)
    globalThis.defineExperience = (config) => config;
    globalThis.defineTool = (config) => ({ risk: "low", capabilities_required: [], ...config });
    globalThis.defineTest = (config) => config;
    globalThis.quickTool = (name, desc, schema, handler) =>
      globalThis.defineTool({ name, description: desc, input_schema: schema, handler });

    // Hooks — implemented inline for the local viewer
    const { useState, useEffect, useCallback, useRef } = React;

    function useSharedState(key, defaultValue) {
      const ctx = globalThis.__vibevibes_ctx__;
      if (!ctx) return [defaultValue, () => {}];
      const value = ctx.sharedState?.[key] ?? defaultValue;
      return [value, () => {}]; // read-only from hooks; mutations go through callTool
    }

    function useToolCall() {
      const ctx = globalThis.__vibevibes_ctx__;
      return ctx?.callTool || (async () => {});
    }

    function useOptimisticTool(callToolOrName, sharedStateArg) {
      const ctx = globalThis.__vibevibes_ctx__;
      // Support both SDK signature: (callTool, sharedState) and legacy: (toolName)
      const isSDKSignature = typeof callToolOrName === "function";
      const callToolFn = isSDKSignature ? callToolOrName : (ctx?.callTool || (async () => {}));
      const serverState = isSDKSignature ? sharedStateArg : (ctx?.sharedState || {});

      const [optimistic, setOptimistic] = useState(null);
      const [pending, setPending] = useState(false);
      const pendingCountRef = useRef(0);

      // When server state arrives and nothing is pending, clear optimistic overlay
      useEffect(() => {
        if (pendingCountRef.current === 0) setOptimistic(null);
      }, [serverState]);

      const call = useCallback(async (nameOrInput, inputOrOptState, maybeOptState) => {
        // SDK signature: call(toolName, input, optimisticState)
        const toolName = isSDKSignature ? nameOrInput : callToolOrName;
        const input = isSDKSignature ? inputOrOptState : nameOrInput;
        const optimisticState = isSDKSignature ? maybeOptState : inputOrOptState;

        // Apply optimistic state IMMEDIATELY — zero latency
        if (optimisticState) setOptimistic(optimisticState);
        setPending(true);
        pendingCountRef.current++;

        try {
          const result = await callToolFn(toolName, input);
          return result;
        } catch (err) {
          // Rollback: server rejected — revert to server state
          setOptimistic(null);
          throw err;
        } finally {
          pendingCountRef.current--;
          if (pendingCountRef.current === 0) {
            setPending(false);
            setOptimistic(null);
          }
        }
      }, [callToolFn, isSDKSignature, callToolOrName]);

      const state = optimistic ? { ...serverState, ...optimistic } : serverState;
      return isSDKSignature ? { call, state, pending } : call;
    }

    function useParticipants() {
      const ctx = globalThis.__vibevibes_ctx__;
      return ctx?.participants || [];
    }

    function useAnimationFrame(callback) {
      const callbackRef = useRef(callback);
      callbackRef.current = callback;
      useEffect(() => {
        let running = true;
        function loop(time) {
          if (!running) return;
          callbackRef.current(time);
          requestAnimationFrame(loop);
        }
        requestAnimationFrame(loop);
        return () => { running = false; };
      }, []);
    }

    function useFollow(actorIdArg, participantsArg, ephState, setEph) {
      const ctx = globalThis.__vibevibes_ctx__;
      const myId = actorIdArg || ctx?.actorId;
      const parts = participantsArg || ctx?.participants || [];
      const es = ephState || ctx?.ephemeralState || {};
      const se = setEph || ctx?.setEphemeral || (() => {});
      const myFollow = es[myId]?._follow || null;

      const follow = useCallback((targetId, mode) => {
        if (targetId === myId) return;
        se({ _follow: { targetActorId: targetId, mode, since: Date.now() } });
      }, [myId, se]);
      const unfollow = useCallback(() => { se({ _follow: null }); }, [se]);

      const followers = [];
      for (const pid of parts) {
        if (pid === myId) continue;
        const pf = es[pid]?._follow;
        if (pf && pf.targetActorId === myId) followers.push({ actorId: pid, mode: pf.mode, since: pf.since });
      }

      return { follow, unfollow, following: myFollow, followers };
    }

    function useTypingIndicator(actorIdArg, ephState, setEph, timeoutMs = 3000) {
      const ctx = globalThis.__vibevibes_ctx__;
      const myId = actorIdArg || ctx?.actorId;
      const es = ephState || ctx?.ephemeralState || {};
      const se = setEph || ctx?.setEphemeral || (() => {});
      const timerRef = useRef(null);

      const setTyping = useCallback((isTyping) => {
        se({ _typing: isTyping ? Date.now() : null });
        if (timerRef.current) clearTimeout(timerRef.current);
        if (isTyping) {
          timerRef.current = setTimeout(() => se({ _typing: null }), timeoutMs);
        }
      }, [se, timeoutMs]);

      useEffect(() => () => { if (timerRef.current) clearTimeout(timerRef.current); }, []);

      const now = Date.now();
      const typingUsers = Object.entries(es)
        .filter(([id, data]) => id !== myId && data._typing && (now - data._typing) < timeoutMs + 2000)
        .map(([id]) => id);

      return { setTyping, typingUsers };
    }

    // useUndo — tracks state snapshots, restores via _state.restore tool
    function useUndo(sharedState, callTool, opts) {
      const maxHistory = opts?.maxHistory ?? 50;
      const restoreTool = opts?.restoreTool ?? '_state.restore';
      const undoStackRef = useRef([]);
      const redoStackRef = useRef([]);
      const lastStateRef = useRef(null);
      const restoringRef = useRef(false);
      const [, forceRender] = useState(0);

      useEffect(() => {
        if (restoringRef.current) { restoringRef.current = false; lastStateRef.current = sharedState; return; }
        if (lastStateRef.current !== null && lastStateRef.current !== sharedState) {
          undoStackRef.current = [...undoStackRef.current.slice(-(maxHistory - 1)), lastStateRef.current];
          redoStackRef.current = [];
          forceRender(n => n + 1);
        }
        lastStateRef.current = sharedState;
      }, [sharedState]);

      const undo = useCallback(() => {
        const stack = undoStackRef.current;
        if (stack.length === 0) return;
        const prev = stack[stack.length - 1];
        undoStackRef.current = stack.slice(0, -1);
        redoStackRef.current = [...redoStackRef.current, sharedState];
        restoringRef.current = true;
        forceRender(n => n + 1);
        callTool(restoreTool, { state: prev }).catch(() => {});
      }, [sharedState, callTool]);

      const redo = useCallback(() => {
        const stack = redoStackRef.current;
        if (stack.length === 0) return;
        const next = stack[stack.length - 1];
        redoStackRef.current = stack.slice(0, -1);
        undoStackRef.current = [...undoStackRef.current, sharedState];
        restoringRef.current = true;
        forceRender(n => n + 1);
        callTool(restoreTool, { state: next }).catch(() => {});
      }, [sharedState, callTool]);

      return { undo, redo, canUndo: undoStackRef.current.length > 0, canRedo: redoStackRef.current.length > 0, undoCount: undoStackRef.current.length, redoCount: redoStackRef.current.length };
    }

    // useDebounce — collapse rapid calls into one after delay
    function useDebounce(callTool, delayMs = 300) {
      const timerRef = useRef(null);
      const latestRef = useRef(null);
      useEffect(() => () => { if (timerRef.current) clearTimeout(timerRef.current); }, []);
      return useCallback((name, input) => {
        latestRef.current = { name, input };
        if (timerRef.current) clearTimeout(timerRef.current);
        return new Promise((resolve, reject) => {
          timerRef.current = setTimeout(async () => {
            const latest = latestRef.current;
            if (!latest) return;
            try { resolve(await callTool(latest.name, latest.input)); } catch (err) { reject(err); }
          }, delayMs);
        });
      }, [callTool, delayMs]);
    }

    // useThrottle — at most one call per interval
    function useThrottle(callTool, intervalMs = 50) {
      const lastCallRef = useRef(0);
      const timerRef = useRef(null);
      const latestRef = useRef(null);
      useEffect(() => () => { if (timerRef.current) clearTimeout(timerRef.current); }, []);
      return useCallback((name, input) => {
        latestRef.current = { name, input };
        const now = Date.now();
        const elapsed = now - lastCallRef.current;
        if (elapsed >= intervalMs) { lastCallRef.current = now; return callTool(name, input); }
        if (timerRef.current) clearTimeout(timerRef.current);
        return new Promise((resolve, reject) => {
          timerRef.current = setTimeout(async () => {
            lastCallRef.current = Date.now();
            const latest = latestRef.current;
            if (!latest) return;
            try { resolve(await callTool(latest.name, latest.input)); } catch (err) { reject(err); }
          }, intervalMs - elapsed);
        });
      }, [callTool, intervalMs]);
    }

    globalThis.undoTool = (zod) => ({
      name: "_state.restore",
      description: "Restore shared state to a previous snapshot (used by undo/redo)",
      input_schema: zod.object({ state: zod.record(zod.any()) }),
      risk: "low", capabilities_required: ["state.write"],
      handler: async (ctx, input) => { ctx.setState(input.state); return { restored: true }; },
    });

    // ── Chat tools ────────────────────────────────────────────
    function _chatUid() { return Math.random().toString(36).slice(2, 10) + Date.now().toString(36); }
    function _capChat(msgs, max = 200) { return msgs.length > max ? msgs.slice(-max) : msgs; }

    globalThis.createChatTools = (zod) => [
      {
        name: "_chat.send",
        description: "Send a chat message",
        input_schema: zod.object({ message: zod.string().min(1).max(2000), replyTo: zod.string().optional() }),
        risk: "low", capabilities_required: ["state.write"],
        handler: async (ctx, input) => {
          const messages = _capChat([...(ctx.state._chat || []), { id: _chatUid(), actorId: ctx.actorId, message: input.message, replyTo: input.replyTo, ts: ctx.timestamp }]);
          ctx.setState({ ...ctx.state, _chat: messages });
          return { sent: true, messageCount: messages.length };
        },
      },
      {
        name: "_chat.clear",
        description: "Clear all chat messages",
        input_schema: zod.object({}),
        risk: "medium", capabilities_required: ["state.write"],
        handler: async (ctx) => { ctx.setState({ ...ctx.state, _chat: [] }); return { cleared: true }; },
      },
    ];

    globalThis.createChatHints = () => [
      { trigger: "A new chat message was sent by a human participant", condition: `(state._chat || []).length > 0 && (state._chat || []).slice(-1)[0]?.actorId?.includes('human')`, suggestedTools: ["_chat.send"], priority: "medium", cooldownMs: 2000 },
    ];

    // ── Bug report tools ──────────────────────────────────────
    globalThis.createBugReportTools = (zod) => [
      {
        name: "_bug.report",
        description: "Submit a bug report with optional screenshot and description",
        input_schema: zod.object({ description: zod.string().max(2000).optional(), screenshot: zod.string().optional(), metadata: zod.record(zod.any()).optional() }),
        risk: "low", capabilities_required: ["state.write"],
        handler: async (ctx, input) => {
          const report = { id: _chatUid(), actorId: ctx.actorId, description: input.description || "", screenshot: input.screenshot, metadata: input.metadata, ts: ctx.timestamp, status: "open" };
          const reports = [...(ctx.state._bugReports || []), report].slice(-50);
          ctx.setState({ ...ctx.state, _bugReports: reports });
          return { reportId: report.id, totalReports: reports.length };
        },
      },
    ];

    globalThis.createBugReportHints = () => [
      { trigger: "A new bug report was submitted", condition: `(state._bugReports || []).some(r => r.status === 'open')`, suggestedTools: [], priority: "low", cooldownMs: 10000 },
    ];

    // ── useChat hook ──────────────────────────────────────────
    function useChat(sharedState, callTool, actorId, ephemeralState, setEphemeral) {
      const messages = sharedState?._chat || [];
      const sendMessage = useCallback(async (message, replyTo) => {
        await callTool("_chat.send", { message, replyTo });
      }, [callTool]);
      const clearChat = useCallback(async () => {
        await callTool("_chat.clear", {});
      }, [callTool]);
      return { messages, sendMessage, clearChat, setTyping: () => {}, typingUsers: [] };
    }

    globalThis.vibevibesHooks = {
      useToolCall, useSharedState, useOptimisticTool, useParticipants,
      useAnimationFrame, useFollow, useTypingIndicator,
      useUndo, useDebounce, useThrottle, useChat,
    };

    // UI Components (minimal inline versions)
    const ce = React.createElement;
    globalThis.vibevibesComponents = {
      Button: ({ onClick, children, variant, ...props }) =>
        ce("button", {
          onClick,
          style: {
            padding: "8px 16px", borderRadius: "6px", cursor: "pointer",
            background: variant === "ghost" ? "transparent" : "#6366f1",
            color: "#fff", border: variant === "ghost" ? "1px solid #334155" : "none",
            fontSize: "14px", ...props.style,
          },
          ...props,
        }, children),
      Card: ({ children, ...props }) =>
        ce("div", {
          style: { background: "#1e1e2e", borderRadius: "12px", padding: "16px", border: "1px solid #334155", ...props.style },
          ...props,
        }, children),
      Input: (props) =>
        ce("input", {
          style: {
            padding: "8px 12px", borderRadius: "6px", background: "#1e293b",
            color: "#fff", border: "1px solid #334155", outline: "none", width: "100%",
            ...props.style,
          },
          ...props,
        }),
      Badge: ({ children, ...props }) =>
        ce("span", {
          style: { padding: "2px 8px", borderRadius: "9999px", background: "#334155", color: "#94a3b8", fontSize: "12px", ...props.style },
          ...props,
        }, children),
      Stack: ({ children, gap, direction, ...props }) =>
        ce("div", {
          style: { display: "flex", flexDirection: direction || "column", gap: gap || "8px", ...props.style },
          ...props,
        }, children),
      Grid: ({ children, columns, gap, ...props }) =>
        ce("div", {
          style: { display: "grid", gridTemplateColumns: `repeat(${columns || 2}, 1fr)`, gap: gap || "8px", ...props.style },
          ...props,
        }, children),
      Slider: ({ value = 50, onChange, min = 0, max = 100, step = 1, disabled, label, ...props }) => {
        const pct = ((value - min) / (max - min)) * 100;
        return ce("div", { style: { display: "flex", flexDirection: "column", gap: "4px", ...props.style } },
          label ? ce("div", { style: { display: "flex", justifyContent: "space-between", fontSize: "13px", color: "#94a3b8" } },
            ce("span", null, label), ce("span", null, String(value))) : null,
          ce("input", { type: "range", min, max, step, value, disabled,
            onChange: onChange ? (e) => onChange(parseFloat(e.target.value)) : undefined,
            style: { width: "100%", height: "6px", appearance: "none", background: `linear-gradient(to right, #6366f1 ${pct}%, #334155 ${pct}%)`, borderRadius: "3px", outline: "none", cursor: disabled ? "not-allowed" : "pointer" },
          })
        );
      },
      Textarea: ({ value, onChange, placeholder, rows = 3, disabled, ...props }) =>
        ce("textarea", { value, placeholder, rows, disabled,
          onChange: onChange ? (e) => onChange(e.target.value) : undefined,
          style: { width: "100%", padding: "8px 12px", fontSize: "14px", border: "1px solid #334155", borderRadius: "6px", background: "#1e293b", color: "#fff", outline: "none", resize: "vertical", boxSizing: "border-box", fontFamily: "system-ui, sans-serif", ...props.style },
        }),
      Modal: ({ children, open, onClose, title, ...props }) => {
        if (!open) return null;
        return ce("div", { onClick: onClose, style: { position: "fixed", inset: 0, zIndex: 10000, display: "flex", alignItems: "center", justifyContent: "center", background: "rgba(0,0,0,0.6)", backdropFilter: "blur(4px)" } },
          ce("div", { onClick: (e) => e.stopPropagation(), style: { background: "#1e1e2e", borderRadius: "12px", padding: "24px", boxShadow: "0 20px 60px rgba(0,0,0,0.5)", maxWidth: "480px", width: "90%", maxHeight: "80vh", overflowY: "auto", border: "1px solid #334155", ...props.style } },
            title ? ce("div", { style: { display: "flex", justifyContent: "space-between", alignItems: "center", marginBottom: "16px" } },
              ce("h3", { style: { margin: 0, fontSize: "1.1rem", fontWeight: 600, color: "#fff" } }, title),
              onClose ? ce("button", { onClick: onClose, style: { background: "none", border: "none", fontSize: "1.25rem", cursor: "pointer", color: "#94a3b8", padding: "4px" } }, "\u2715") : null
            ) : null,
            children
          )
        );
      },
      ColorPicker: ({ value = "#6366f1", onChange, presets, disabled, ...props }) => {
        const colors = presets || ["#ef4444","#f97316","#eab308","#22c55e","#06b6d4","#3b82f6","#6366f1","#8b5cf6","#ec4899","#ffffff","#94a3b8","#0a0a0a"];
        return ce("div", { style: { display: "flex", flexWrap: "wrap", gap: "6px", alignItems: "center", ...props.style } },
          ...colors.map(c => ce("button", { key: c, onClick: !disabled && onChange ? () => onChange(c) : undefined,
            style: { width: "28px", height: "28px", borderRadius: "50%", border: c === value ? "2px solid #fff" : "2px solid transparent", background: c, cursor: disabled ? "not-allowed" : "pointer", outline: c === value ? "2px solid #6366f1" : "none", outlineOffset: "2px", padding: 0 } })),
          ce("input", { type: "color", value, disabled, onChange: onChange ? (e) => onChange(e.target.value) : undefined,
            style: { width: "28px", height: "28px", padding: 0, border: "none", borderRadius: "50%", cursor: "pointer" } })
        );
      },
      Dropdown: ({ value, onChange, options = [], placeholder, disabled, ...props }) =>
        ce("select", { value: value || "", disabled, onChange: onChange ? (e) => onChange(e.target.value) : undefined,
          style: { width: "100%", padding: "8px 12px", fontSize: "14px", border: "1px solid #334155", borderRadius: "6px", background: "#1e293b", color: "#fff", outline: "none", cursor: "pointer", appearance: "none", paddingRight: "2rem", ...props.style } },
          placeholder ? ce("option", { value: "", disabled: true }, placeholder) : null,
          ...options.map(o => ce("option", { key: o.value, value: o.value }, o.label))
        ),
      Tabs: ({ tabs = [], activeTab, onTabChange, children, ...props }) => {
        const active = activeTab || tabs[0]?.id;
        return ce("div", { style: { ...props.style } },
          ce("div", { style: { display: "flex", borderBottom: "1px solid #334155", gap: 0 } },
            ...tabs.map(t => ce("button", { key: t.id, onClick: onTabChange ? () => onTabChange(t.id) : undefined,
              style: { padding: "8px 16px", fontSize: "13px", fontWeight: 500, background: "none", border: "none", cursor: "pointer", color: t.id === active ? "#6366f1" : "#94a3b8", borderBottom: t.id === active ? "2px solid #6366f1" : "2px solid transparent", marginBottom: "-1px" } }, t.label))
          ),
          ce("div", { style: { paddingTop: "12px" } }, children)
        );
      },
      // ── ChatPanel ─────────────────────────────────────────
      ChatPanel: function ChatPanel({ sharedState, callTool, actorId, ephemeralState, setEphemeral, participants, ...props }) {
        const [open, setOpen] = useState(false);
        const [inputVal, setInputVal] = useState("");
        const [sending, setSending] = useState(false);
        const [lastSeen, setLastSeen] = useState(0);
        const listRef = useRef(null);
        const messages = sharedState?._chat || [];
        const unread = open ? 0 : Math.max(0, messages.length - lastSeen);

        useEffect(() => { if (open) setLastSeen(messages.length); }, [open, messages.length]);
        useEffect(() => { if (listRef.current) listRef.current.scrollTop = listRef.current.scrollHeight; }, [messages.length]);

        function _parseActor(id) {
          const m = id.match(/^(.+)-(human|ai)-(\d+)$/);
          return m ? { username: m[1], type: m[2] } : { username: id, type: "unknown" };
        }
        function _fmtTime(ts) { return new Date(ts).toLocaleTimeString([], { hour: "2-digit", minute: "2-digit" }); }
        const colors = { human: "#60a5fa", ai: "#a78bfa", unknown: "#94a3b8" };

        async function handleSend() {
          const text = inputVal.trim();
          if (!text || sending) return;
          setSending(true); setInputVal("");
          try { await callTool("_chat.send", { message: text }); } catch {} finally { setSending(false); }
        }

        const toggleBtn = ce("button", { onClick: () => setOpen(!open), title: "Chat",
          style: { position: "fixed", bottom: "64px", right: "16px", zIndex: 9990, width: "40px", height: "40px", borderRadius: "50%", background: "#1e1e2e", border: "1px solid #334155", color: "#94a3b8", fontSize: "18px", cursor: "pointer", display: "flex", alignItems: "center", justifyContent: "center", ...props.style } },
          ce("svg", { width: 20, height: 20, viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: 2, strokeLinecap: "round", strokeLinejoin: "round" },
            ce("path", { d: "M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z" })),
          unread > 0 ? ce("span", { style: { position: "absolute", top: "-4px", right: "-4px", width: "18px", height: "18px", borderRadius: "50%", background: "#6366f1", color: "#fff", fontSize: "10px", fontWeight: 700, display: "flex", alignItems: "center", justifyContent: "center" } }, unread > 9 ? "9+" : String(unread)) : null
        );

        if (!open) return toggleBtn;

        return ce("div", null,
          toggleBtn,
          ce("div", { style: { position: "fixed", bottom: "112px", right: "16px", zIndex: 9990, width: "320px", maxHeight: "500px", borderRadius: "12px", background: "#111113", border: "1px solid #1e1e24", boxShadow: "0 8px 32px rgba(0,0,0,0.5)", display: "flex", flexDirection: "column", overflow: "hidden", fontFamily: "system-ui, -apple-system, sans-serif" } },
            // Header
            ce("div", { style: { padding: "12px 16px", borderBottom: "1px solid #1e1e24", display: "flex", justifyContent: "space-between", alignItems: "center" } },
              ce("span", { style: { fontSize: "12px", fontWeight: 700, color: "#6b6b80", textTransform: "uppercase", letterSpacing: "0.06em" } }, "Chat"),
              ce("button", { onClick: () => setOpen(false), style: { background: "none", border: "none", color: "#6b6b80", cursor: "pointer", fontSize: "16px", padding: "2px" } }, "\u2715")),
            // Messages
            ce("div", { ref: listRef, style: { flex: 1, overflowY: "auto", padding: "8px 12px", display: "flex", flexDirection: "column", gap: "6px", minHeight: "200px", maxHeight: "340px" } },
              messages.length === 0
                ? ce("div", { style: { color: "#4a4a5a", fontSize: "13px", textAlign: "center", padding: "32px 0" } }, "No messages yet")
                : messages.map(msg => {
                    const { username, type } = _parseActor(msg.actorId);
                    const isMe = msg.actorId === actorId;
                    return ce("div", { key: msg.id, style: { display: "flex", flexDirection: "column", alignItems: isMe ? "flex-end" : "flex-start" } },
                      ce("div", { style: { display: "flex", gap: "6px", alignItems: "baseline", flexDirection: isMe ? "row-reverse" : "row" } },
                        ce("span", { style: { fontSize: "11px", fontWeight: 600, color: colors[type] || colors.unknown } }, username),
                        ce("span", { style: { fontSize: "10px", color: "#4a4a5a" } }, _fmtTime(msg.ts))),
                      ce("div", { style: { background: isMe ? "#6366f1" : "#1e1e2e", color: isMe ? "#fff" : "#e2e2e8", padding: "6px 10px", borderRadius: "10px", borderTopRightRadius: isMe ? "2px" : "10px", borderTopLeftRadius: isMe ? "10px" : "2px", fontSize: "13px", lineHeight: 1.4, maxWidth: "240px", wordBreak: "break-word" } }, msg.message));
                  })),
            // Input
            ce("div", { style: { padding: "8px 12px", borderTop: "1px solid #1e1e24", display: "flex", gap: "8px" } },
              ce("input", { type: "text", value: inputVal, onChange: (e) => setInputVal(e.target.value), onKeyDown: (e) => { if (e.key === "Enter" && !e.shiftKey) { e.preventDefault(); handleSend(); } }, placeholder: "Type a message...", disabled: sending,
                style: { flex: 1, padding: "6px 10px", fontSize: "13px", border: "1px solid #334155", borderRadius: "6px", background: "#1e293b", color: "#fff", outline: "none", fontFamily: "system-ui, sans-serif" } }),
              ce("button", { onClick: handleSend, disabled: sending || !inputVal.trim(),
                style: { padding: "6px 12px", borderRadius: "6px", background: "#6366f1", color: "#fff", border: "none", fontSize: "13px", cursor: sending || !inputVal.trim() ? "not-allowed" : "pointer", opacity: sending || !inputVal.trim() ? 0.5 : 1, fontWeight: 500 } }, "Send"))
          )
        );
      },
      // ── ReportBug ─────────────────────────────────────────
      ReportBug: function ReportBug({ callTool, actorId, ...props }) {
        const [phase, setPhase] = useState("idle"); // idle | capturing | form | submitted
        const [screenshot, setScreenshot] = useState(null);
        const [desc, setDesc] = useState("");
        const [submitting, setSubmitting] = useState(false);

        async function captureScreenshot() {
          try {
            const root = document.getElementById("root");
            if (!root) return null;
            const canvases = root.querySelectorAll("canvas");
            if (canvases.length === 1) {
              const cvs = canvases[0];
              const rr = root.getBoundingClientRect(), cr = cvs.getBoundingClientRect();
              if (Math.abs(cr.width - rr.width) < 20 && Math.abs(cr.height - rr.height) < 20) return cvs.toDataURL("image/png");
            }
            if (typeof html2canvas === "function") {
              const captured = await html2canvas(root, { backgroundColor: "#0a0a0a", useCORS: true, logging: false, scale: 0.5 });
              return captured.toDataURL("image/png");
            }
            return null;
          } catch { return null; }
        }

        async function handleOpen() {
          setPhase("capturing");
          const dataUrl = await captureScreenshot();
          setScreenshot(dataUrl);
          setPhase("form");
        }
        function handleCancel() { setPhase("idle"); setScreenshot(null); setDesc(""); }
        async function handleSubmit() {
          if (submitting) return;
          setSubmitting(true);
          try {
            await callTool("_bug.report", { description: desc || undefined, screenshot: screenshot || undefined, metadata: { userAgent: navigator.userAgent } });
            setPhase("submitted"); setDesc(""); setScreenshot(null);
            setTimeout(() => setPhase("idle"), 2000);
          } catch {} finally { setSubmitting(false); }
        }

        const bugBtn = ce("button", { onClick: phase === "idle" ? handleOpen : undefined, title: "Report Bug",
          style: { position: "fixed", bottom: "112px", right: "16px", zIndex: 9990, width: "40px", height: "40px", borderRadius: "50%", background: phase === "capturing" ? "#334155" : "#1e1e2e", border: "1px solid #334155", color: "#94a3b8", fontSize: "18px", cursor: phase === "idle" ? "pointer" : "default", display: "flex", alignItems: "center", justifyContent: "center", ...props.style } },
          phase === "submitted"
            ? ce("svg", { width: 18, height: 18, viewBox: "0 0 24 24", fill: "none", stroke: "#22c55e", strokeWidth: 2.5, strokeLinecap: "round", strokeLinejoin: "round" }, ce("polyline", { points: "20 6 9 17 4 12" }))
            : ce("svg", { width: 18, height: 18, viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: 2, strokeLinecap: "round", strokeLinejoin: "round" },
                ce("ellipse", { cx: 12, cy: 14, rx: 5, ry: 6 }), ce("path", { d: "M12 8V2" }), ce("path", { d: "M9 3l3 5 3-5" }),
                ce("path", { d: "M7 14H2" }), ce("path", { d: "M22 14h-5" }), ce("path", { d: "M7.5 10.5L4 8" }), ce("path", { d: "M16.5 10.5L20 8" }))
        );

        if (phase !== "form") return bugBtn;

        return ce("div", null,
          bugBtn,
          ce("div", { onClick: handleCancel, style: { position: "fixed", inset: 0, zIndex: 9995, display: "flex", alignItems: "center", justifyContent: "center", background: "rgba(0,0,0,0.6)", backdropFilter: "blur(4px)" } },
            ce("div", { onClick: (e) => e.stopPropagation(), style: { background: "#1e1e2e", borderRadius: "12px", padding: "20px", boxShadow: "0 20px 60px rgba(0,0,0,0.5)", maxWidth: "400px", width: "90%", border: "1px solid #334155", fontFamily: "system-ui, sans-serif" } },
              ce("div", { style: { display: "flex", justifyContent: "space-between", alignItems: "center", marginBottom: "16px" } },
                ce("h3", { style: { margin: 0, fontSize: "1.1rem", fontWeight: 600, color: "#fff" } }, "Report Bug"),
                ce("button", { onClick: handleCancel, style: { background: "none", border: "none", fontSize: "1.25rem", cursor: "pointer", color: "#94a3b8", padding: "4px" } }, "\u2715")),
              screenshot ? ce("img", { src: screenshot, alt: "Screenshot", style: { width: "100%", borderRadius: "8px", marginBottom: "12px", border: "1px solid #334155" } })
                : ce("div", { style: { padding: "24px", textAlign: "center", color: "#6b6b80", fontSize: "13px", border: "1px dashed #334155", borderRadius: "8px", marginBottom: "12px" } }, "Screenshot unavailable"),
              ce("textarea", { value: desc, onChange: (e) => setDesc(e.target.value), placeholder: "What's wrong? (optional)", rows: 3,
                style: { width: "100%", padding: "8px 12px", fontSize: "13px", border: "1px solid #334155", borderRadius: "6px", background: "#1e293b", color: "#fff", outline: "none", resize: "vertical", boxSizing: "border-box", fontFamily: "system-ui, sans-serif", marginBottom: "12px" } }),
              ce("div", { style: { display: "flex", gap: "8px", justifyContent: "flex-end" } },
                ce("button", { onClick: handleCancel, style: { padding: "8px 16px", borderRadius: "6px", background: "transparent", color: "#94a3b8", border: "1px solid #334155", fontSize: "13px", cursor: "pointer", fontWeight: 500 } }, "Cancel"),
                ce("button", { onClick: handleSubmit, disabled: submitting, style: { padding: "8px 16px", borderRadius: "6px", background: "#ef4444", color: "#fff", border: "none", fontSize: "13px", cursor: submitting ? "not-allowed" : "pointer", opacity: submitting ? 0.5 : 1, fontWeight: 500 } }, submitting ? "Sending..." : "Submit Report"))
            )
          )
        );
      },
    };

    // ── Activity panel ─────────────────────────────────────

    let activityPanelOpen = false;
    let unseenEvents = 0;
    const activityEvents = [];
    const MAX_ACTIVITY_EVENTS = 100;

    globalThis.toggleActivityPanel = function() {
      activityPanelOpen = !activityPanelOpen;
      document.getElementById("activity-panel").classList.toggle("open", activityPanelOpen);
      if (activityPanelOpen) {
        unseenEvents = 0;
        updateToggleBadge();
      }
    };

    function updateToggleBadge() {
      const toggle = document.getElementById("activity-toggle");
      let badge = toggle.querySelector(".badge");
      if (unseenEvents > 0) {
        if (!badge) { badge = document.createElement("span"); badge.className = "badge"; toggle.appendChild(badge); }
        badge.textContent = unseenEvents > 9 ? "9+" : String(unseenEvents);
      } else if (badge) {
        badge.remove();
      }
    }

    function parseActorId(id) {
      const m = id.match(/^(.+)-(human|ai)-(\d+)$/);
      if (m) return { username: m[1], type: m[2] };
      return { username: id, type: "unknown" };
    }

    function updateParticipantList(participants) {
      const el = document.getElementById("participant-list");
      const countEl = document.getElementById("participant-count");
      countEl.textContent = String(participants.length);
      el.innerHTML = "";
      for (const pid of participants) {
        const { username, type } = parseActorId(pid);
        const chip = document.createElement("span");
        chip.className = `participant-chip ${type}`;
        chip.textContent = (type === "ai" ? "\u{1F916} " : "") + username;
        chip.title = pid;
        el.appendChild(chip);
      }
    }

    function addActivityEvent(event) {
      activityEvents.push(event);
      if (activityEvents.length > MAX_ACTIVITY_EVENTS) activityEvents.shift();

      const log = document.getElementById("event-log");
      const countEl = document.getElementById("event-count");
      countEl.textContent = String(activityEvents.length);

      const entry = document.createElement("div");
      entry.className = "event-entry";

      const { type: actorType } = parseActorId(event.actorId || "unknown");
      const time = new Date(event.ts).toLocaleTimeString([], { hour: "2-digit", minute: "2-digit", second: "2-digit" });

      entry.innerHTML = `<span class="event-time">${time}</span>`
        + `<span class="event-actor ${actorType}">${event.actorId}</span> `
        + `<span class="event-tool">${event.tool}</span>`
        + (event.error ? ` <span class="event-error">ERR</span>` : "");

      log.appendChild(entry);
      log.scrollTop = log.scrollHeight;

      if (!activityPanelOpen) {
        unseenEvents++;
        updateToggleBadge();
      }
    }

    // ── Toast notifications ─────────────────────────────────

    function showToast(message, type = "error", durationMs = 6000) {
      const container = document.getElementById("toast-container");
      const toast = document.createElement("div");
      toast.className = type === "build" ? "toast toast-build" : "toast";
      toast.textContent = message;
      toast.onclick = () => toast.remove();
      container.appendChild(toast);
      setTimeout(() => { if (toast.parentNode) toast.remove(); }, durationMs);
    }

    // ── Connect to the experience ─────────────────────────────

    const SERVER = location.origin;
    const WS_PROTO = location.protocol === "https:" ? "wss:" : "ws:";
    const WS_URL = `${WS_PROTO}//${location.host}`;

    // Room-aware: read ?room= query param (defaults to "local" for host experience)
    const ROOM_ID = new URLSearchParams(location.search).get("room") || "local";
    const ROOM_TOKEN = new URLSearchParams(location.search).get("token") || "";

    function showError(msg) {
      document.getElementById("loading").style.display = "none";
      document.getElementById("error-display").style.display = "block";
      document.getElementById("error-message").textContent = msg;
    }

    async function start() {
      try {
        // Connect WebSocket — single room, no room ID needed
        const ws = new WebSocket(WS_URL);

        let actorId = "viewer";
        let sharedState = {};
        let participants = [];
        let roomConfig = {};
        let Canvas = null;
        let hotReloadKey = 0;

        // ── Optimistic state layer ──────────────────────────────
        // Tracks in-flight optimistic overlays keyed by a unique call ID.
        // Each overlay is { state: {...}, ts: number }.
        // Display state = sharedState merged with all active overlays.
        let optimisticOverlays = new Map();
        let optimisticSeq = 0;

        function getDisplayState() {
          if (optimisticOverlays.size === 0) return sharedState;
          let merged = { ...sharedState };
          for (const overlay of optimisticOverlays.values()) {
            Object.assign(merged, overlay.state);
          }
          return merged;
        }

        // ── Ephemeral state (high-frequency, no tool gate) ──────
        let ephemeralState = {};

        function setEphemeral(data) {
          ephemeralState = {
            ...ephemeralState,
            [actorId]: { ...(ephemeralState[actorId] || {}), ...data },
          };
          // Broadcast to server for relay to other participants
          if (ws.readyState === WebSocket.OPEN) {
            ws.send(JSON.stringify({ type: "ephemeral", actorId, data }));
          }
          render();
        }

        function render() {
          if (!Canvas || !reactRoot) return;

          const displayState = getDisplayState();

          // Expose context for hooks
          globalThis.__vibevibes_ctx__ = {
            sharedState: displayState,
            callTool,
            participants,
            actorId,
            ephemeralState,
            setEphemeral,
          };

          reactRoot.render(
            ce(CanvasErrorBoundary, { key: hotReloadKey },
              ce(Canvas, {
                roomId: ROOM_ID,
                actorId,
                sharedState: displayState,
                callTool,
                participants,
                ephemeralState,
                setEphemeral,
                roomConfig,
              })
            )
          );
        }

        async function callTool(name, input, _optimisticState) {
          // If an optimistic state is provided, apply it IMMEDIATELY
          let overlayId = null;
          if (_optimisticState) {
            overlayId = ++optimisticSeq;
            optimisticOverlays.set(overlayId, { state: _optimisticState, ts: Date.now() });
            render(); // Re-render with predicted state at T=0ms
          }

          try {
            const baseToolUrl = ROOM_ID === "local"
              ? `${SERVER}/tools/${name}`
              : `${SERVER}/rooms/${ROOM_ID}/tools/${name}`;
            const toolUrl = ROOM_TOKEN ? `${baseToolUrl}?token=${ROOM_TOKEN}` : baseToolUrl;
            const res = await fetch(toolUrl, {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({ actorId, input: input || {} }),
            });
            const data = await res.json();
            if (data.error) {
              showToast(data.error);
              throw new Error(data.error);
            }
            return data.output;
          } catch (err) {
            if (!err.message || !document.querySelector(".toast")) {
              showToast(`Tool '${name}' failed: ${err.message}`);
            }
            throw err;
          } finally {
            // Clear this overlay — server state broadcast will take over
            if (overlayId !== null) {
              optimisticOverlays.delete(overlayId);
              render(); // Re-render with server-authoritative state
            }
          }
        }

        // Error boundary component
        class CanvasErrorBoundary extends React.Component {
          constructor(props) {
            super(props);
            this.state = { error: null };
          }
          static getDerivedStateFromError(error) { return { error }; }
          componentDidCatch(error, info) {
            console.error("[viewer] Experience crashed:", error, info?.componentStack);
          }
          render() {
            if (this.state.error) {
              return ce("div", {
                style: { padding: "32px", textAlign: "center", color: "#ef4444" },
              },
                ce("h2", null, "Experience Crashed"),
                ce("pre", { style: { fontSize: "13px", color: "#94a3b8", marginTop: "12px", whiteSpace: "pre-wrap" } },
                  this.state.error.message),
                ce("button", {
                  onClick: () => this.setState({ error: null }),
                  style: { marginTop: "16px", padding: "8px 16px", background: "#6366f1", color: "#fff", border: "none", borderRadius: "6px", cursor: "pointer" },
                }, "Try Again"),
              );
            }
            return this.props.children;
          }
        }

        ws.onopen = () => {
          reconnectAttempts = 0; // Reset backoff on successful connection
          const savedActorId = sessionStorage.getItem("vibevibes_actorId");
          ws.send(JSON.stringify({ type: "join", username: "viewer", roomId: ROOM_ID, actorId: savedActorId }));
        };

        ws.onmessage = async (event) => {
          const msg = JSON.parse(event.data);

          if (msg.type === "joined") {
            actorId = msg.actorId;
            sessionStorage.setItem("vibevibes_actorId", actorId);
            sharedState = msg.sharedState || {};
            participants = msg.participants || [];
            roomConfig = msg.config || {};

            // Load client bundle (room-aware: external experiences get their own bundle)
            try {
              const bundleUrl = ROOM_ID === "local"
                ? `${SERVER}/bundle?_t=${Date.now()}`
                : `${SERVER}/rooms/${ROOM_ID}/bundle?_t=${Date.now()}`;
              const bundleRes = await fetch(bundleUrl);
              const bundleCode = await bundleRes.text();

              const blob = new Blob([bundleCode], { type: "text/javascript" });
              const url = URL.createObjectURL(blob);
              const mod = await import(url);
              URL.revokeObjectURL(url);

              const experience = mod.default ?? mod;
              if (!experience?.Canvas) throw new Error("Experience has no Canvas component");

              Canvas = experience.Canvas;
              if (!reactRoot) {
                reactRoot = ReactDOM.createRoot(document.getElementById("root"));
              }

              document.getElementById("loading").style.display = "none";
              render();
              updateParticipantList(participants);
            } catch (err) {
              showError(`Failed to load experience: ${err.message}`);
            }
          }

          if (msg.type === "shared_state_update") {
            sharedState = msg.state;
            participants = msg.participants || participants;
            // Server is authoritative — clear all optimistic overlays.
            // If prediction was correct, display doesn't change (merged state ≈ server state).
            // If prediction was wrong, we snap to server truth.
            optimisticOverlays.clear();
            render();
            updateParticipantList(participants);
            if (msg.event) addActivityEvent(msg.event);
          }

          if (msg.type === "ephemeral") {
            // Another participant's ephemeral data — merge into ephemeralState
            const senderId = msg.actorId;
            if (senderId && senderId !== actorId) {
              ephemeralState = {
                ...ephemeralState,
                [senderId]: { ...(ephemeralState[senderId] || {}), ...msg.data },
              };
              render();
            }
          }

          if (msg.type === "presence_update") {
            participants = msg.participants || participants;
            render();
            updateParticipantList(participants);
          }

          if (msg.type === "experience_updated") {
            // Hot reload: re-fetch bundle and re-render
            try {
              const bundleUrl = ROOM_ID === "local"
                ? `${SERVER}/bundle?_t=${Date.now()}`
                : `${SERVER}/rooms/${ROOM_ID}/bundle?_t=${Date.now()}`;
              const bundleRes = await fetch(bundleUrl);
              const bundleCode = await bundleRes.text();

              const blob = new Blob([bundleCode], { type: "text/javascript" });
              const url = URL.createObjectURL(blob);
              const mod = await import(url);
              URL.revokeObjectURL(url);

              const experience = mod.default ?? mod;
              if (experience?.Canvas) {
                Canvas = experience.Canvas;
                hotReloadKey++;
                render();
                console.log("[viewer] Hot reloaded");
              }
            } catch (err) {
              console.error("[viewer] Hot reload failed:", err);
              showToast(`Hot reload failed: ${err.message}`, "build", 10000);
            }
          }

          if (msg.type === "build_error") {
            showToast(`Build error: ${msg.error}`, "build", 10000);
          }

          if (msg.type === "screenshot_request") {
            const requestId = msg.id;
            // Small delay to let any pending React renders settle
            setTimeout(async () => {
              try {
                const root = document.getElementById("root");
                if (!root) throw new Error("No #root element");

                let dataUrl;

                // Fast path: single <canvas> filling #root → native toDataURL
                const canvases = root.querySelectorAll("canvas");
                if (canvases.length === 1) {
                  const cvs = canvases[0];
                  const rootRect = root.getBoundingClientRect();
                  const cvsRect = cvs.getBoundingClientRect();
                  const fillsRoot =
                    Math.abs(cvsRect.width - rootRect.width) < 20 &&
                    Math.abs(cvsRect.height - rootRect.height) < 20;
                  if (fillsRoot) {
                    dataUrl = cvs.toDataURL("image/png");
                  }
                }

                // Fallback: html2canvas for DOM/SVG/mixed content
                if (!dataUrl && typeof html2canvas === "function") {
                  const captured = await html2canvas(root, {
                    backgroundColor: "#0a0a0a",
                    useCORS: true,
                    logging: false,
                    scale: 1,
                  });
                  dataUrl = captured.toDataURL("image/png");
                }

                if (!dataUrl) throw new Error("No capture method available");

                ws.send(JSON.stringify({
                  type: "screenshot_response",
                  id: requestId,
                  dataUrl,
                }));
              } catch (err) {
                ws.send(JSON.stringify({
                  type: "screenshot_response",
                  id: requestId,
                  error: err.message,
                }));
              }
            }, 100);
          }
        };

        ws.onerror = (err) => {
          console.error("[viewer] WebSocket error:", err);
        };

        // Reconnect with exponential backoff (no full page reload)
        ws.onclose = () => {
          const delay = Math.min(1000 * Math.pow(2, reconnectAttempts), 15000);
          reconnectAttempts++;
          console.log(`[viewer] WebSocket closed, reconnecting in ${delay}ms (attempt ${reconnectAttempts})...`);
          showToast(`Disconnected. Reconnecting in ${Math.round(delay/1000)}s...`, "info", delay + 1000);
          setTimeout(() => start(), delay);
        };

      } catch (err) {
        showError(err.message);
      }
    }

    let reconnectAttempts = 0;
    let reactRoot = null; // Persists across reconnects to avoid duplicate roots
    start();
  </script>
</body>
</html>
